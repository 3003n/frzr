#! /bin/bash

set -e
set -o pipefail

if [[ -n "${DEBUG}" ]]; then
	set -x
fi

get_img_url() {
	CHANNEL=$1
	local keywords="img"

	# Order by creation date in reverse
	result=$(jq 'sort_by(.created_at) | reverse')

	# Remove entries which have not been completed uploading
	result=$(echo "${result}" | jq 'del(.[] | select(.assets[].state != "uploaded"))')

	# Always check for stable date
	if stable_release_date=$(echo "${result}" | jq -er '[ .[] |
			select(.prerelease==false) ] |
			first |
			.created_at'
		); then
		# Check for stable url, this is the latest that have prerelease == false
		stable_download_url=$(echo "${result}" | jq -r '[ .[] |
			select(.prerelease==false) ] |
			first |
			.assets[] |
			select(.browser_download_url | test("'$keywords'")) |
			.browser_download_url'
		)
	else
		# No stable channel found, pick some (old) values
		# For testing/ channel selection
		stable_release_date="1970-01-01T00:00:00Z"
		stable_download_url=""
	fi

	# Filter channels by release naming conventions
	if [[ "$CHANNEL" =~ ^[0-9]+\-?[0-9]*$ ]] ; then
		# Check first for explicit version numbers between stable releases
		# Useful for downgrading
		result=$(echo "${result}" | jq -r "[ .[] |
					select(.prerelease==false) |
					select(.name|test(\" ${CHANNEL}\$\")) ] |
					first |
					.assets[] |
					select(.browser_download_url | test(\"${keywords}\")) |
					.browser_download_url"
				)
	elif [ "$CHANNEL" == "stable" ]; then
		result=$stable_download_url
	elif [ "$CHANNEL" == "testing" ]; then
		# Testing channel have prerelease = true and no other tags
		if testing_release_date=$(echo "${result}" | jq -er '[ .[] |
			select(.prerelease==true) |
			select(.name|test("\\[.*\\]")|not) ] |
			first |
			.created_at'
			); then
			testing_url=$(echo "${result}" | jq -r '[ .[] |
						select(.prerelease==true) |
						select(.name|test("\\[.*\\]")|not) ] |
						first |
						.assets[] |
						select(.browser_download_url | test("'$keywords'")) |
						.browser_download_url'
					)

			if [ $(date -d $testing_release_date +%s) -le $(date -d $stable_release_date +%s) ]; then
				result=$stable_download_url
			else
				result=$testing_url
			fi
		else
			result=$stable_download_url
		fi
	else
		# 如果 CHANNEL 以 -任意字符结尾
		if [[ "$CHANNEL" =~ -[^-]*$ ]]; then
			# CHANNEL 去掉最后一个 - 及其后面的内容
			CHANNEL_STABLE=$(echo "${CHANNEL}" | sed 's/-[^-]*$//')
			result_stable=$(echo ${result} | jq "[ .[] | select(.name|test(\"\\\[${CHANNEL_STABLE}\\\]\" ; \"i\")) ]")
			if stable_release_date=$(echo "${result_stable}" | jq -er "[ .[] |
					select(.name|test(\"\\\[${CHANNEL_STABLE}\\\]\" ; \"i\")) ] |
					first |
					.created_at"
				); then
				stable_download_url=$(echo "${result_stable}" | jq -r "[ .[] |
					select(.name|test(\"\\\[${CHANNEL_STABLE}\\\]\" ; \"i\")) ] |
					first |
					.assets[] |
					select(.browser_download_url | test(\"$keywords\")) |
					.browser_download_url"
				)
			fi
		fi


		# Match any release with CHANNEL as a tag (including unstable)
		result=$(echo ${result} | jq "[ .[] | select(.prerelease==true) | select(.name|test(\"\\\[${CHANNEL}\\\]\" ; \"i\")) ]")
		if unstable_release_date=$(echo "${result}" | jq -er "[ .[] |
					select(.prerelease==true) |
					select(.name|test(\"\\\[${CHANNEL}\\\]\" ; \"i\")) ] |
					first |
					.created_at"
				); then
			unstable_url=$(echo "${result}" | jq -r "[ .[] |
						select(.prerelease==true) |
						select(.name|test(\"\\\[${CHANNEL}\\\]\" ; \"i\")) ] |
						first |
						.assets[] |
						select(.browser_download_url | test(\"$keywords\")) |
						.browser_download_url"
					)
			
			unstable_release_time=$(date -d $unstable_release_date +%s)
			stable_release_time=$(date -d $stable_release_date +%s)
			# CHANNEL 为 unstable 或者 CHANNEL_STABLE 不为空, 并且 unstable_release_time 小于等于 stable_release_time
			if [[ "$CHANNEL" == "unstable" || ! -z "$CHANNEL_STABLE" ]] && [ $unstable_release_time -le $stable_release_time ]; then
				result=$stable_download_url
			else
				result=$unstable_url
			fi
			
		else
			result=$stable_download_url
		fi
	fi

	echo $result
}

mk_swapfile() {
	SWAPFILE=${1:-}
	SWAPSIZE=${2:-}

	dd if=/dev/zero of="$SWAPFILE" bs=1M count="$SWAPSIZE"
	chmod 600 "$SWAPFILE"
	mkswap -U clear "$SWAPFILE" 
}

create_swap() {
    local mount_path=${1}
    local deployment_dir=${2}

	local ram_info=$(dmidecode -t 17 | grep Size)
	local ram_size=$(echo "$ram_info" | awk '{sum += $2} END {print sum}')

	local available_space=$(df -B 1G --output=avail "$mount_path" | tail -n 1)
    local required_space=ram_size

	SWAPFILE="$mount_path/swap/swapfile"
	SWAPSIZE="${ram_size}GiB"

	# check swap subvolume
	if [ ! -d "$mount_path/swap" ]; then
    	echo "$mount_path/swap does not exist. creating subvolume..."

    	# create subvolume
    	btrfs subvolume create $mount_path/swap
		chattr +C $mount_path/swap
	else
    	# check if subvolume exists
    	if btrfs subvolume show "$mount_path/swap" &> /dev/null; then
    		echo "$mount_path/swap is a Btrfs subvolume."
    	else
    		echo "$mount_path/swap exists but is not a Btrfs subvolume."
    		rm -rf $mount_path/swap
    		btrfs subvolume create $mount_path/swap
    		chattr +C $mount_path/swap
    	fi
	fi

	# create swapfile
	echo "Creating swapfile..."
    if [ ! -f "$SWAPFILE" ]; then
        # btrfs filesystem mkswapfile --size "$ram_size"GiB "$mount_path/swap/swapfile"
		
		mk_swapfile "$SWAPFILE" "$SWAPSIZE"
    else
        echo "Swapfile appears to already exist"
		existing_file_type=$(file "$SWAPFILE" | cut -d' ' -f2-)
		if [[ "$existing_file_type" == *"Linux swap file"* ]]; then
			echo "Swapfile is a Linux swap file"
			if swapon --show | grep -q "$SWAPFILE"; then
				echo "Swapfile is already enabled"
			else
				echo "Enabling swapfile"
				swapon "$SWAPFILE"
				if [ $? -ne 0 ]; then
					echo "Failed to enable swapfile"
					rm -rf $SWAPFILE
					mk_swapfile "$SWAPFILE" "$SWAPSIZE"
				fi
			fi
		else
			echo "Swapfile exists but is not a Linux swap file"
			rm -rf $SWAPFILE
			mk_swapfile "$SWAPFILE" "$SWAPSIZE"
		fi
	fi
}

create_nix() {
	local mount_path=${1}

	nix_path="$mount_path/nix"
	# check nix subvolume
	if [ ! -d "$nix_path" ]; then
		echo "$nix_path does not exist. creating subvolume..."

		# create subvolume
		btrfs subvolume create $nix_path
	else
		# check if subvolume exists
		if btrfs subvolume show "$nix_path" &> /dev/null; then
			echo "$nix_path is a Btrfs subvolume."
		else
			echo "$nix_path exists but is not a Btrfs subvolume."
			rm -rf $nix_path
			btrfs subvolume create $nix_path
		fi
	fi
}

get_fbcon() {

	if [[ -x $(command -v parse-edid) && -f "/etc/sk-chos/screen-rotate" ]]; then
		source /etc/sk-chos/screen-rotate
		if [[ -n "$FBCON_PARA" ]]; then
        	echo "fbcon=$FBCON_PARA"
			return 0
		fi
    fi

	# Device specific configs
	DEVICENAME=$(cat /sys/devices/virtual/dmi/id/product_name)

	# OXP
	OXP_LIST="ONE XPLAYER:ONEXPLAYER 1 T08:ONEXPLAYER 1S A08:ONEXPLAYER 1S T08:ONEXPLAYER mini A07:ONEXPLAYER mini GA72:ONEXPLAYER mini GT72:ONEXPLAYER Mini Pro:ONEXPLAYER GUNDAM GA72:ONEXPLAYER 2 ARP23:ONEXPLAYER 2 PRO ARP23P:ONEXPLAYER 2 PRO ARP23P EVA-01:ONEXPLAYER F1"
	# AOKZOE
	AOK_LIST="AOKZOE A1 AR07:AOKZOE A1 Pro"
	# AYANEO AIR
	AIR_LIST="AIR:AIR Pro:AIR 1S"
	AYN_LIST="Loki Max:Loki Zero:Loki MiniPro"
	# Lenovo
	LENOVO_LIST="83E1"

	# AYANEO AYA
	AYA_LIST="NEXT:NEXT Pro:NEXT Advance:AYANEO NEXT:AYANEO NEXT Pro:AYANEO NEXT Advance:AYA NEO Fouder:AYA NEO 2021:AYANEO 2021:AYANEO 2021 Pro:AYANEO 2021 Pro:AYANEO 2021 Pro Retro Power:AYANEO 2:GEEK:AYANEO 2S:GEEK 1S"
	# GPD
	GPD_LIST="G1619-01:G1621-02:MicroPC:G1617-01"


	LEFT_LIST="${OXP_LIST}:${AIR_LIST}:${AOK_LIST}:${AYN_LIST}:${LENOVO_LIST}"
	RIGHT_LIST="${AYA_LIST}:${GPD_LIST}"

	if [[  ":${LEFT_LIST}:" =~ ":${DEVICENAME}:" ]]; then
		echo "video=efifb fbcon=rotate:3"
	elif [[ ":${RIGHT_LIST}:" =~ ":${DEVICENAME}:" ]]; then
		echo "video=efifb fbcon=rotate:1"
	else
		echo ""
	fi

}

get_boot_cfg() {
	local version=${1}
	local amd_ucode=${2}
	local intel_ucode=${3}
	local additional_arguments=${4}
	local swap_arguments=${5}
	local fbcon=${6}

echo "title ${version}
linux /${version}/vmlinuz-linux
${amd_ucode}
${intel_ucode}
initrd /${version}/initramfs-linux.img
options root=LABEL=frzr_root rw rootflags=subvol=deployments/${version} quiet splash loglevel=3 rd.systemd.show_status=auto rd.udev.log_priority=3 ${additional_arguments} ${swap_arguments} ${fbcon}"

}

get_deployment_to_delete() {
	local current_version=${1}
	local boot_cfg_path=${2}
	local deployment_path=${3}

	local TO_BOOT=`get_next_boot_deployment ${current_version} ${boot_cfg_path}`

	ls -1 ${deployment_path} | grep -v ${current_version} | grep -v ${TO_BOOT} || echo
}

get_boot_to_delete() {
	local current_version=${1}
	local boot_cfg_path=${2}
	local boot_path=${3}

	local TO_BOOT=`get_next_boot_deployment ${current_version} ${boot_cfg_path}`

	ls -1 ${boot_path} | grep 'chimeraos-*_*' | grep -v ${current_version} | grep -v ${TO_BOOT} || echo
}

get_next_boot_deployment() {
	local current_version=${1}
	local boot_cfg_path=${2}

	local TO_BOOT='this-is-not-a-valid-version-string'
	if [ -f "${boot_cfg_path}" ] && grep "^title" "${boot_cfg_path}" > /dev/null; then
		TO_BOOT=`grep ^title ${boot_cfg_path} | sed 's/title //'`
	fi

	echo ${TO_BOOT}
}

clean_progress() {
	local scale=$1
	local postfix=$2
	local last_value=$scale
	local start_value=${3:-0}
	while IFS= read -r line || [[ -n $line ]]; do
		value=$(( ${line}*${scale}/100 + ${start_value} ))
		if [ "$last_value" != "$value" ]; then
			echo ${value}${postfix}
			last_value=$value
		fi
	done
}

# Function to retrieve values from a .conf file
# Usage: getValue filename section key
get_conf_value() {
    local filename="$1"
    local section="$2"
    local key="$3"

    local section_found=false
    local key_found=false
    local values=()

    while IFS= read -r line || [[ -n $line ]]; do
        # Remove leading and trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Check if the line is a comment or empty
        if [[ $line == \#* ]] || [[ -z $line ]]; then
            continue
        fi

        # Check if the line matches the section header
        if [[ $line == "[$section]" ]]; then
            section_found=true
        elif [[ $line == '['* ]]; then
            # If a new section is encountered, break
            if $section_found; then
                break
            fi
        elif $section_found; then
            # Check if the line contains the desired key
            if [[ $line == *"$key"* ]]; then
                local value=$(echo "$line" | sed -n "s/.*$key *= *\([^ ]*\).*/\1/p")
                values+=("$value")
                key_found=true
            fi
        fi
    done < "$filename"

    if $key_found; then
        if [ "${#values[@]}" -eq 1 ]; then
            # If only one value is found, return it
            echo "${values[0]}"
        else
            # If multiple values are found, return them as an array
            echo "${values[@]}"
        fi
    fi
}

get_random_value() {
    local array=("$@")
    local array_length="${#array[@]}"
    
    if [ "$array_length" -eq 0 ]; then
        echo ""
    fi

    local random_index=$((RANDOM % array_length))
    echo "${array[$random_index]}"
}

get_fallback_url_justlist() {
	local base_url=$1
	local img_file_name=$2

	fallback_base="http://honjow.cn:5044"
	fallback_api_url="${fallback_base}/api/get/list/Cloud189/img/"
	fallback_file_url="${fallback_base}/file/Cloud189/img/"

	local fallback_url=$(curl --http1.1 -L -s "${base_url}/fallback_url.txt")
	# if fallback_url.txt contains "Not Found" 
	if echo "$fallback_url" | grep -q "Not Found"; then
		fallback_url=""
		# get the fallback url from the fallback api
		file_info=$(curl --http1.1 -L -s -d "{}" -H "Content-Type:application/json" "${fallback_api_url}${img_file_name}")
		if [[ ! -z "$file_info" ]]; then
			fallback_file_id=$(echo "$file_info" | jq -r '.msg | first | .fileId' 2> /dev/null)
			fallback_user=$(echo "$file_info" | jq -r '.msg | first | .user' 2> /dev/null)
			if [[ ! -z "$fallback_file_id" && "$fallback_file_id" != "null" ]]; then
				fallback_url="${fallback_file_url}${img_file_name}"
				# fallback_url="${fallback_base}/file/${fallback_user}/?id=${fallback_file_id}"
			fi
		fi
  	fi
	echo "$fallback_url"
}

get_fallback_url_alist() {
	local img_file_name=$1

	fallback_base="https://ns.switchsystem.eu.org/d/guest/stos/img/"
	image_url="${fallback_base}${img_file_name}"

	# 使用 curl 获取链接的状态码是否是 302，如果是 302，说明链接有效，echo 出来
	if curl --http1.1 -s -o /dev/null -w "%{http_code}" "$image_url" | grep -q "302"; then
		echo "$image_url"
	fi
}


main() {
	if [ $EUID -ne 0 ]; then
		echo "$(basename $0) must be run as root"
		exit 1
	fi

	FRZR_CHECK_UPDATE=0
	FRZR_STEAM_PROGRESS=0
	FRZR_SOURCE=""
	FRZR_PARAMS=""

	while (( "$#" )); do
		case $1 in
			--check)
				FRZR_CHECK_UPDATE=1
				shift
				;;
			--steam-progress)
				FRZR_STEAM_PROGRESS=1
				shift
				;;
			-*|--*)
				echo "Unknown argument $1"
				exit 1
				;;
			*) # preserve positional arguments
				FRZR_PARAMS="${FRZR_PARAMS}$1 " # Use trailing space for the match below
				shift
				;;
		esac
	done

	if [ ! -d /sys/firmware/efi/efivars ]; then
		echo "Legacy BIOS installs are not supported. Aborting."
		exit 1
	fi

	# keep only the first param as source
	FRZR_SOURCE="${FRZR_PARAMS%% *}"

	MOUNT_PATH=/frzr_root

	if ! mountpoint -q ${MOUNT_PATH}; then
		MOUNT_PATH=/tmp/frzr_root
	fi

	if ! mountpoint -q ${MOUNT_PATH}; then
		mkdir -p ${MOUNT_PATH}
		mount -L frzr_root ${MOUNT_PATH}
		sleep 5
	fi

	if ! mountpoint -q ${MOUNT_PATH}/boot && ls -1 /dev/disk/by-label | grep frzr_efi > /dev/null; then
		mkdir -p ${MOUNT_PATH}/boot
		mount -L frzr_efi ${MOUNT_PATH}/boot
		sleep 5
	fi

	DEPLOY_PATH=${MOUNT_PATH}/deployments
	mkdir -p ${DEPLOY_PATH}

	BOOT_CFG="${MOUNT_PATH}/boot/loader/entries/frzr.conf"
	mkdir -p ${MOUNT_PATH}/boot/loader/entries

	# delete deployments under these conditions:
	# - we are currently running inside a frzr deployment (i.e. not during install)
	# - the deployment is not currently running
	# - the deployment is not configured to be run on next boot
	if frzr-release > /dev/null; then
		CURRENT="$(frzr-release)"
		TO_DELETE=`get_deployment_to_delete ${CURRENT} ${BOOT_CFG} ${DEPLOY_PATH}`

		TO_DELETE_BOOT=`get_boot_to_delete ${CURRENT} ${BOOT_CFG} ${MOUNT_PATH}/boot`

		if [ -n "${TO_DELETE}" ]; then
			for deployment in ${TO_DELETE}; do
				echo "deleting ${deployment}..."
				rm -rf ${MOUNT_PATH}/boot/${deployment} || true
				btrfs subvolume delete ${DEPLOY_PATH}/${deployment} || true
			done
		fi

		if [ -n "${TO_DELETE_BOOT}" ]; then
			# if multiple boot entries are found, delete all of them
			for boot_entry in ${TO_DELETE_BOOT}; do
				echo "deleting boot entry ${boot_entry}..."
				rm -rf ${MOUNT_PATH}/boot/${boot_entry} || true
			done
		fi
	fi

	if [ ! -z "$FRZR_SOURCE" ] && [ "$FRZR_SOURCE" != " " ] && [ $FRZR_CHECK_UPDATE -eq 0 ] && [ $FRZR_STEAM_PROGRESS -eq 0 ]; then
		echo "$FRZR_SOURCE" > "${MOUNT_PATH}/source"
	fi

	if [ -e "${MOUNT_PATH}/source" ]; then
		SOURCE=`cat "${MOUNT_PATH}/source" | head -1`
	else
		echo "WARNING: source wasn't specified"
	fi

	if [ "${local_install}" == true ]; then
	    mkdir tmp_source
	    mount -o rw -L FRZR_UPDATE /root/tmp_source
		FILE_NAME=$(basename /root/tmp_source/*.img.tar.xz*)
		NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
		SUBVOL="${DEPLOY_PATH}/${NAME}"
		IMG_FILE="/root/tmp_source/${FILE_NAME}"
	elif [[ "$FRZR_SOURCE" =~ \.img(\.tar\.xz|\.xz|\.zst)?$ ]]; then
		FILE_NAME=$(basename ${FRZR_SOURCE})
		NAME=$(echo "${FILE_NAME}" | cut -f 1 -d '.')
		SUBVOL="${DEPLOY_PATH}/${NAME}"
		IMG_FILE=${FRZR_SOURCE}
	else
		REPO=$(echo "${SOURCE}" | cut -f 1 -d ':')
		CHANNEL=$(echo "${SOURCE}" | cut -f 2 -d ':')

		RELEASES_URL="https://api.github.com/repos/${REPO}/releases"

		FRZR_SK_CONFIG="/etc/frzr-sk.conf"
		if [ -f "${FRZR_SK_CONFIG}" ]; then
			enable_api_cdn=($(get_conf_value "${FRZR_SK_CONFIG}" "Download" "api_cdn"))
			enable_release_cdn=($(get_conf_value "${FRZR_SK_CONFIG}" "Download" "release_cdn"))
			enable_fallback_url=($(get_conf_value "${FRZR_SK_CONFIG}" "Download" "fallback_url"))
		fi

		# echo -e "enable_api_cdn = ${enable_api_cdn}\nenable_release_cdn = ${enable_release_cdn}\nenable_fallback_url = ${enable_fallback_url}"

		GITHUB_CDN_FILE="/etc/github_cdn.conf"
		if [ -f "${GITHUB_CDN_FILE}" ]; then
			api_cdns=($(get_conf_value "${GITHUB_CDN_FILE}" "api" "server"))
			if [[ -n "${api_cdns}" && "$enable_api_cdn" == "true" ]]; then
				API_CND=$(get_random_value "${api_cdns[@]}")
				echo "# API: ${API_CND} #"
				RELEASES_URL="${API_CND}/repos/${REPO}/releases"
			fi
		fi

		set +e
		RELEASES=$(curl --http1.1 -L -s --connect-timeout 10 -m 15 "${RELEASES_URL}")
		status=$?
		set -e
		case $status in
			28)
				echo "Failed to fetch releases: Connection timed out"
				exit $status
				;;
			35)
				echo "Failed to fetch releases: SSL connect error"
				exit $status
				;;
			0)
				;;
			*)
				echo "Failed to fetch releases, status code: $status"
				exit $status
				;;
		esac

		if echo "$RELEASES" | grep -q "API rate limit"; then
			echo "GitHub API rate limit exceeded"
			exit 29
		fi

		IMG_LIST_URL=$(echo $RELEASES | get_img_url "${CHANNEL}")
		if [ -f "${GITHUB_CDN_FILE}" ]; then
			img_cdns=($(get_conf_value "${GITHUB_CDN_FILE}" "release" "server"))
			if [[ -n "${img_cdns}" && "$enable_release_cdn" == "true" ]]; then
				IMG_CND=$(get_random_value "${img_cdns[@]}")
				echo "# Release: ${IMG_CND} #"
				IMG_LIST_URL=$(echo "${IMG_LIST_URL}" | sed "s#^https://.*/${REPO}#${IMG_CND}/${REPO}#")
			fi
		fi

		if [ -z "$IMG_LIST_URL" ] || [[ "$IMG_LIST_URL" =~ "null" ]]; then
			echo "No matching source found"
			if curl --http1.1 -L -s --connect-timeout 5 -m 15 "${RELEASES_URL}" | grep "rate limit" > /dev/null; then
				echo "GitHub API rate limit exceeded"
				exit 29
			fi
			exit 1
		fi

		BASE_URL=$(dirname $(echo "${IMG_LIST_URL}" | cut -d' ' -f1))
		IMG_LIST_STR="$(curl --http1.1 -L -s --connect-timeout 5 -m 15 ${BASE_URL}/sha256sum.txt)"

		echo "$IMG_LIST_STR"
		CHECKSUM_LIST=$(echo "$IMG_LIST_STR" | awk '{print $1}')

		IMG_FILE_NAME=$(basename ${IMG_LIST_URL} | sed 's/-[0-9]*$//')
		NAME=$(echo "${IMG_FILE_NAME}" | cut -f 1 -d '.')
		SUBVOL="${DEPLOY_PATH}/${NAME}"
		IMG_FILE="${MOUNT_PATH}/${IMG_FILE_NAME}"

		SER=0
		TOTAL=$(echo "$CHECKSUM_LIST" | wc -l)

		for CHECKSUM in $CHECKSUM_LIST; do

			FILE_NAME=$(echo "$IMG_LIST_STR" | grep $CHECKSUM | awk '{print $2}')
			SUB_IMG_FILE="${MOUNT_PATH}/${FILE_NAME}"
			SUB_IMG_URL="${BASE_URL}/${FILE_NAME}"

			if [[ "$enable_fallback_url" == "true" ]]; then
				FALLBACK_URL_AL=$(get_fallback_url_alist "${FILE_NAME}")
				if [[ -n "$FALLBACK_URL_AL" ]]; then
					FALLBACK_URL="${FALLBACK_URL_AL}"
				else
					FALLBACK_URL_JL=$(get_fallback_url_justlist "${BASE_URL}" "${FILE_NAME}")
					if [[ -n "$FALLBACK_URL_JL" ]]; then
						FALLBACK_URL="${FALLBACK_URL_JL}"
					fi
				fi
			fi
	
			# if the fallback url is not empty, set the img_url to the fallback url
			if [[ -n "$FALLBACK_URL" ]]; then
				if [[ ! $FRZR_CHECK_UPDATE -eq 1 ]]; then
					echo "Fallback URL: ${FALLBACK_URL}"
				fi
				SUB_IMG_URL="${FALLBACK_URL}"
			fi
	
	
			if [ -e ${SUBVOL} ]; then
				echo "${NAME} already installed; aborting"
				exit 7 # let Steam know there is no update available
			fi
	
			if [ $FRZR_CHECK_UPDATE -eq 1 ]; then
				# if [[ -n "$FALLBACK_URL" ]]; then
				# 	fallback_msg="(with_fallback)"
				# fi
				if [[ -n "$FALLBACK_URL_AL" ]]; then
					fallback_msg="(alist)"
				fi
				if [[ -n "$FALLBACK_URL_JL" ]]; then
					fallback_msg="(jlist)"
				fi
				echo "${NAME}　${fallback_msg}"
				exit 0 # let Steam know there is an update available
			fi

			echo "Downloading ${NAME} ($((SER + 1))/${TOTAL})..."
	
			if [[ -x "$(command -v aria2c)" ]];then
				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					max_progress=91
					start_progress=$((SER * max_progress / TOTAL))
					aria2c --connect-timeout=10 --file-allocation=none -x 16 -s 16 \
					--checksum=sha-256="${CHECKSUM}" --auto-file-renaming=false --allow-overwrite=true \
					--console-log-level=warn --stderr=true -o "${FILE_NAME}" -d "${MOUNT_PATH}" "${SUB_IMG_URL}" 2>&1 | \
					grep --line-buffered -oP '\d+(?=%)' | clean_progress $max_progress % $start_progress
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${FILE_NAME}..."
					aria2c --connect-timeout=10 --file-allocation=none -x 16 -s 16 \
					--checksum=sha-256="${CHECKSUM}" --auto-file-renaming=false --allow-overwrite=true \
					--console-log-level=warn -o "${FILE_NAME}" -d "${MOUNT_PATH}" "${SUB_IMG_URL}"
				else
					max_progress=100
					start_progress=$((SER * max_progress / TOTAL))
					aria2c --connect-timeout=10 --file-allocation=none -x 16 -s 16 \
					--checksum=sha-256="${CHECKSUM}" --auto-file-renaming=false --allow-overwrite=true \
					--console-log-level=warn --stderr=true -o "${FILE_NAME}" -d "${MOUNT_PATH}" "${SUB_IMG_URL}" 2>&1 | \
					grep --line-buffered -oP '\d+(?=%)' | clean_progress $max_progress '' $start_progress | \
					whiptail --gauge "下载系统镜像 (${NAME}) " 10 50 0
				fi
			else
				if [ $FRZR_STEAM_PROGRESS -eq 1 ]; then
					max_progress=91
					start_progress=$((SER * max_progress / TOTAL))
					curl --connect-timeout 10 --http1.1 -# -L -o "${SUB_IMG_FILE}" -C - "${SUB_IMG_URL}" 2>&1 | \
					stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | \
					clean_progress $max_progress % $start_progress
				elif [ -z ${SHOW_UI} ]; then
					echo "downloading ${FILE_NAME}..."
					curl --connect-timeout 10 --http1.1 -L -o "${SUB_IMG_FILE}" -C - "${SUB_IMG_URL}"
				else
					max_progress=100
					start_progress=$((SER * max_progress / TOTAL))
					curl --connect-timeout 10 --http1.1 -# -L -o "${SUB_IMG_FILE}" -C - "${SUB_IMG_URL}" 2>&1 | \
					stdbuf -oL tr '\r' '\n' | grep --line-buffered -oP '[0-9]*+(?=.[0-9])' | \
					clean_progress $max_progress '' $start_progress | \
					whiptail --gauge "下载系统镜像 (${NAME})" 10 50 0
				fi
			fi

			CHECKSUM_CALCULATED=`sha256sum "${SUB_IMG_FILE}" | cut -d' ' -f 1`
			if [ "$CHECKSUM" != "$CHECKSUM_CALCULATED" ]; then
				rm -f "${SUB_IMG_FILE}"
				echo "checksum does not match; aborting"
				exit 1
			fi

			SER=$((SER+1))
		done
    fi

	if [ -z ${SHOW_UI} ]; then
		echo "installing ${NAME}..."
	else
		whiptail --infobox "提取并安装系统镜像 (${NAME}), 这可能需要一些时间。" 10 50
	fi

	# 对分割的文件进行合并
	if [ -f "${IMG_FILE}-000" ]; then
		echo "merging split files..."
		cat ${IMG_FILE}-* > ${IMG_FILE}
		rm -f ${IMG_FILE}-*
		echo "split files merge complete"
	fi

	# if [[ "${IMG_FILE##*.}" == "img" ]]; then
	# 	btrfs receive --quiet ${DEPLOY_PATH} < ${IMG_FILE}
	# else
	# 	tar xfO ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
	# fi
	if [[ "${IMG_FILE##*.}" == "img" ]]; then
		btrfs receive --quiet ${DEPLOY_PATH} < ${IMG_FILE}
	elif [[ "${IMG_FILE##*.}" == "zst" ]]; then
		zstd -d -c ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
	elif [[ "${IMG_FILE##*.}" == "xz" ]]; then
		if [[ "${IMG_FILE}" == *".tar.xz" ]]; then
			tar xfO ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
		else
			xz -dc ${IMG_FILE} | btrfs receive --quiet ${DEPLOY_PATH}
		fi
	else
		# Handle other cases or provide an error message
		echo "Unsupported file format: ${IMG_FILE}"
	fi

	mkdir -p ${MOUNT_PATH}/boot/${NAME}
	cp ${SUBVOL}/boot/vmlinuz-linux ${MOUNT_PATH}/boot/${NAME}
	cp ${SUBVOL}/boot/initramfs-linux.img ${MOUNT_PATH}/boot/${NAME}

	echo "show boot files"
	ls -R ${SUBVOL}/boot/

	# now that the initramfs has been built determine if that includes microcode
	AMD_UCODE="# missing intel-ucode"
	INTEL_UCODE="# missing intel-ucode"

	if grep -q "microcode" "/etc/mkinitcpio.conf"; then
		echo "microcode hook present: will skip systemd-boot initrd."

		AMD_UCODE="# amd-ucode in initramfs"
		INTEL_UCODE="# intel-ucode in initramfs"
	else
		echo "microcode hook not found: will use systemd-bood initrd."
		if [ -e ${SUBVOL}/boot/amd-ucode.img ] ; then
			cp ${SUBVOL}/boot/amd-ucode.img ${MOUNT_PATH}/boot/${NAME}
			AMD_UCODE="initrd /${NAME}/amd-ucode.img"
		fi

		if [ -e ${SUBVOL}/boot/intel-ucode.img ] ; then
			cp ${SUBVOL}/boot/intel-ucode.img ${MOUNT_PATH}/boot/${NAME}
			INTEL_UCODE="initrd /${NAME}/intel-ucode.img"
		fi
	fi

	ADDITIONAL_ARGUMENTS=""
	if [ -e ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf ] ; then
		ADDITIONAL_ARGUMENTS="$ADDITIONAL_ARGUMENTS $(cat ${SUBVOL}/usr/lib/frzr.d/bootconfig.conf)"
	fi

	# create_swap "${MOUNT_PATH}" "${SUBVOL}"
	SWAP_ARGUMENTS=""
	if [ -f ${MOUNT_PATH}/swap/swapfile ] ; then
		resume="resume=PARTUUID=$(lsblk -no PARTUUID $(mount | grep " ${MOUNT_PATH} " | cut -d' ' -f1))"
		resume_offset="resume_offset=$(btrfs inspect-internal map-swapfile -r ${MOUNT_PATH}/swap/swapfile)"
		SWAP_ARGUMENTS="${resume} ${resume_offset}"
	fi

	# create_nix "${MOUNT_PATH}"

	FBCON="$(get_fbcon)"

	# get_boot_cfg "${NAME}" "${AMD_UCODE}" "${INTEL_UCODE}" "${ADDITIONAL_ARGUMENTS}" "${SWAP_ARGUMENTS} ${FBCON}" > ${BOOT_CFG}
	BOOT_CFG_PARA=$(get_boot_cfg "${NAME}" "${AMD_UCODE}" "${INTEL_UCODE}" "${ADDITIONAL_ARGUMENTS}" "${SWAP_ARGUMENTS}" "${FBCON}")
	echo "${BOOT_CFG_PARA}" > ${BOOT_CFG}
	export BOOT_CFG_PARA="${BOOT_CFG_PARA}"
	echo "default frzr.conf" > ${MOUNT_PATH}/boot/loader/loader.conf

	# Check if there are migrations available
	if compgen -G "${SUBVOL}"/usr/lib/frzr.d/*.migration > /dev/null ; then
		for m in "${SUBVOL}"/usr/lib/frzr.d/*.migration ;
		do
			unset -f post_install
			. $m
			if [ "$(type -t post_install)" == function ] ; then
				post_install "${MOUNT_PATH}" "${SUBVOL}" "${NAME}"
			fi
			unset -f post_install
		done
	fi

	# Export variables to be used by child processes for frzr-tweaks and frzr-initramfs
	export MOUNT_PATH
	export SUBVOL
	export NAME

	# Check if the FIRMWARE_OVERRIDE variable is set by the install media, if so enable firmware overrides
	if [ -n "${FIRMWARE_OVERRIDE}" ]; then
		echo "export USE_FIRMWARE_OVERRIDES=1" > ${MOUNT_PATH}/etc/device-quirks.conf
	fi

	# Run frzr-tweaks to execute the device-quirks to be supplied by the deployed images
	frzr-tweaks

	# Run frzr-initramfs to create mkinicpio.conf and build an initramfs
	frzr-initramfs

	rm -f ${MOUNT_PATH}/*.img.*

	rm -rf /var/lib/pacman # undo frzr-unlock

	echo "deployment complete; restart to boot into ${NAME}"
}


if [ "$0" = "$BASH_SOURCE" ] ; then
	main "$@"
fi